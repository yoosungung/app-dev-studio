/*
 * Copyright 2016 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Table_1;
import * as tslib_1 from "tslib";
import { AbstractComponent2, DISPLAYNAME_PREFIX, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils, } from "@blueprintjs/core";
import classNames from "classnames";
import * as React from "react";
import { polyfill } from "react-lifecycles-compat";
import { Column } from "./column";
import * as Classes from "./common/classes";
import { Clipboard } from "./common/clipboard";
import { columnInteractionBarContextTypes } from "./common/context";
import { Direction } from "./common/direction";
import * as Errors from "./common/errors";
import { Grid } from "./common/grid";
import * as FocusedCellUtils from "./common/internal/focusedCellUtils";
import * as ScrollUtils from "./common/internal/scrollUtils";
import * as SelectionUtils from "./common/internal/selectionUtils";
import { Rect } from "./common/rect";
import { RenderMode } from "./common/renderMode";
import { Utils } from "./common/utils";
import { ColumnHeader } from "./headers/columnHeader";
import { ColumnHeaderCell } from "./headers/columnHeaderCell";
import { renderDefaultRowHeader, RowHeader } from "./headers/rowHeader";
import { ResizeSensor } from "./interactions/resizeSensor";
import { GuideLayer } from "./layers/guides";
import { RegionLayer } from "./layers/regions";
import { Locator } from "./locator";
import { QuadrantType } from "./quadrants/tableQuadrant";
import { TableQuadrantStack } from "./quadrants/tableQuadrantStack";
import { ColumnLoadingOption, RegionCardinality, Regions, SelectionModes, TableLoadingOption, } from "./regions";
import { TableBody } from "./tableBody";
let Table = Table_1 = class Table extends AbstractComponent2 {
    constructor(props, context) {
        super(props, context);
        this.refHandlers = {
            cellContainer: (ref) => (this.cellContainerElement = ref),
            columnHeader: (ref) => (this.columnHeaderElement = ref),
            quadrantStack: (ref) => (this.quadrantStackInstance = ref),
            rootTable: (ref) => (this.rootTableElement = ref),
            rowHeader: (ref) => (this.rowHeaderElement = ref),
            scrollContainer: (ref) => (this.scrollContainerElement = ref),
        };
        /*
         * This value is set to `true` when all cells finish mounting for the first
         * time. It serves as a signal that we can switch to batch rendering.
         */
        this.didCompletelyMount = false;
        // Selection resize
        // ----------------
        this.handleSelectionResizeUp = (e) => this.handleSelectionResize(e, Direction.UP);
        this.handleSelectionResizeDown = (e) => this.handleSelectionResize(e, Direction.DOWN);
        this.handleSelectionResizeLeft = (e) => this.handleSelectionResize(e, Direction.LEFT);
        this.handleSelectionResizeRight = (e) => this.handleSelectionResize(e, Direction.RIGHT);
        this.handleSelectionResize = (e, direction) => {
            e.preventDefault();
            e.stopPropagation();
            const { focusedCell, selectedRegions } = this.state;
            if (selectedRegions.length === 0) {
                return;
            }
            const index = FocusedCellUtils.getFocusedOrLastSelectedIndex(selectedRegions, focusedCell);
            const region = selectedRegions[index];
            const nextRegion = SelectionUtils.resizeRegion(region, direction, focusedCell);
            this.updateSelectedRegionAtIndex(nextRegion, index);
        };
        this.handleCopy = (e) => {
            const { getCellClipboardData, onCopy } = this.props;
            const { selectedRegions } = this.state;
            if (getCellClipboardData == null) {
                return;
            }
            // prevent "real" copy from being called
            e.preventDefault();
            e.stopPropagation();
            const cells = Regions.enumerateUniqueCells(selectedRegions, this.grid.numRows, this.grid.numCols);
            const sparse = Regions.sparseMapCells(cells, getCellClipboardData);
            if (sparse != null) {
                const success = Clipboard.copyCells(sparse);
                CoreUtils.safeInvoke(onCopy, success);
            }
        };
        this.renderMenu = (refHandler) => {
            const classes = classNames(Classes.TABLE_MENU, {
                [Classes.TABLE_SELECTION_ENABLED]: Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_TABLE),
            });
            return (React.createElement("div", { className: classes, ref: refHandler, onMouseDown: this.handleMenuMouseDown }, this.maybeRenderRegions(this.styleMenuRegion)));
        };
        this.handleMenuMouseDown = (e) => {
            // the shift+click interaction expands the region from the focused cell.
            // thus, if shift is pressed we shouldn't move the focused cell.
            this.selectAll(!e.shiftKey);
        };
        this.selectAll = (shouldUpdateFocusedCell) => {
            const selectionHandler = this.getEnabledSelectionHandler(RegionCardinality.FULL_TABLE);
            // clicking on upper left hand corner sets selection to "all"
            // regardless of current selection state (clicking twice does not deselect table)
            selectionHandler([Regions.table()]);
            if (shouldUpdateFocusedCell) {
                const newFocusedCellCoordinates = Regions.getFocusCellCoordinatesFromRegion(Regions.table());
                this.handleFocus(FocusedCellUtils.toFullCoordinates(newFocusedCellCoordinates));
            }
        };
        this.handleSelectAllHotkey = (e) => {
            // prevent "real" select all from happening as well
            e.preventDefault();
            e.stopPropagation();
            // selecting-all via the keyboard should not move the focused cell.
            this.selectAll(false);
        };
        this.columnHeaderCellRenderer = (columnIndex) => {
            const props = this.getColumnProps(columnIndex);
            if (props === undefined) {
                return null;
            }
            const { id, loadingOptions, cellRenderer, columnHeaderCellRenderer, ...spreadableProps } = props;
            const columnLoading = this.hasLoadingOption(loadingOptions, ColumnLoadingOption.HEADER);
            if (columnHeaderCellRenderer != null) {
                const columnHeaderCell = columnHeaderCellRenderer(columnIndex);
                const columnHeaderCellLoading = columnHeaderCell.props.loading;
                const columnHeaderCellProps = {
                    loading: columnHeaderCellLoading != null ? columnHeaderCellLoading : columnLoading,
                };
                return React.cloneElement(columnHeaderCell, columnHeaderCellProps);
            }
            const baseProps = {
                index: columnIndex,
                loading: columnLoading,
                ...spreadableProps,
            };
            if (props.name != null) {
                return React.createElement(ColumnHeaderCell, Object.assign({}, baseProps));
            }
            else {
                return React.createElement(ColumnHeaderCell, Object.assign({}, baseProps, { name: Utils.toBase26Alpha(columnIndex) }));
            }
        };
        this.renderColumnHeader = (refHandler, resizeHandler, reorderingHandler, showFrozenColumnsOnly = false) => {
            const { focusedCell, selectedRegions, viewportRect } = this.state;
            const { enableMultipleSelection, enableGhostCells, enableColumnReordering, enableColumnResizing, loadingOptions, maxColumnWidth, minColumnWidth, selectedRegionTransform, } = this.props;
            const classes = classNames(Classes.TABLE_COLUMN_HEADERS, {
                [Classes.TABLE_SELECTION_ENABLED]: Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_COLUMNS),
            });
            const columnIndices = this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);
            const columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart;
            const columnIndexEnd = showFrozenColumnsOnly ? this.getMaxFrozenColumnIndex() : columnIndices.columnIndexEnd;
            return (React.createElement("div", { className: classes },
                React.createElement(ColumnHeader, { enableMultipleSelection: enableMultipleSelection, cellRenderer: this.columnHeaderCellRenderer, focusedCell: focusedCell, grid: this.grid, isReorderable: enableColumnReordering, isResizable: enableColumnResizing, loading: this.hasLoadingOption(loadingOptions, TableLoadingOption.COLUMN_HEADERS), locator: this.locator, maxColumnWidth: maxColumnWidth, measurableElementRef: refHandler, minColumnWidth: minColumnWidth, onColumnWidthChanged: this.handleColumnWidthChanged, onFocusedCell: this.handleFocus, onLayoutLock: this.handleLayoutLock, onReordered: this.handleColumnsReordered, onReordering: reorderingHandler, onResizeGuide: resizeHandler, onSelection: this.getEnabledSelectionHandler(RegionCardinality.FULL_COLUMNS), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd }, this.props.children),
                this.maybeRenderRegions(this.styleColumnHeaderRegion)));
        };
        this.renderRowHeader = (refHandler, resizeHandler, reorderingHandler, showFrozenRowsOnly = false) => {
            const { focusedCell, selectedRegions, viewportRect } = this.state;
            const { enableMultipleSelection, enableGhostCells, enableRowReordering, enableRowResizing, loadingOptions, maxRowHeight, minRowHeight, rowHeaderCellRenderer, selectedRegionTransform, } = this.props;
            const classes = classNames(Classes.TABLE_ROW_HEADERS, {
                [Classes.TABLE_SELECTION_ENABLED]: Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_ROWS),
            });
            const rowIndices = this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);
            const rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart;
            const rowIndexEnd = showFrozenRowsOnly ? this.getMaxFrozenRowIndex() : rowIndices.rowIndexEnd;
            return (React.createElement("div", { className: classes, ref: refHandler },
                React.createElement(RowHeader, { enableMultipleSelection: enableMultipleSelection, focusedCell: focusedCell, grid: this.grid, locator: this.locator, isReorderable: enableRowReordering, isResizable: enableRowResizing, loading: this.hasLoadingOption(loadingOptions, TableLoadingOption.ROW_HEADERS), maxRowHeight: maxRowHeight, minRowHeight: minRowHeight, onFocusedCell: this.handleFocus, onLayoutLock: this.handleLayoutLock, onResizeGuide: resizeHandler, onReordered: this.handleRowsReordered, onReordering: reorderingHandler, onRowHeightChanged: this.handleRowHeightChanged, onSelection: this.getEnabledSelectionHandler(RegionCardinality.FULL_ROWS), rowHeaderCellRenderer: rowHeaderCellRenderer, selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd }),
                this.maybeRenderRegions(this.styleRowHeaderRegion)));
        };
        this.bodyCellRenderer = (rowIndex, columnIndex) => {
            const columnProps = this.getColumnProps(columnIndex);
            if (columnProps === undefined) {
                return null;
            }
            const { id, loadingOptions, cellRenderer, columnHeaderCellRenderer, name, nameRenderer, ...restColumnProps } = columnProps;
            const cell = cellRenderer(rowIndex, columnIndex);
            const { loading = this.hasLoadingOption(loadingOptions, ColumnLoadingOption.CELLS) } = cell.props;
            const cellProps = {
                ...restColumnProps,
                loading,
            };
            return React.cloneElement(cell, cellProps);
        };
        this.renderBody = (quadrantType, showFrozenRowsOnly = false, showFrozenColumnsOnly = false) => {
            const { focusedCell, numFrozenColumnsClamped: numFrozenColumns, numFrozenRowsClamped: numFrozenRows, selectedRegions, viewportRect, } = this.state;
            const { enableMultipleSelection, enableGhostCells, loadingOptions, bodyContextMenuRenderer, selectedRegionTransform, } = this.props;
            const rowIndices = this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);
            const columnIndices = this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);
            // start beyond the frozen area if rendering unrelated quadrants, so we
            // don't render duplicate cells underneath the frozen ones.
            const columnIndexStart = showFrozenColumnsOnly ? 0 : columnIndices.columnIndexStart + numFrozenColumns;
            const rowIndexStart = showFrozenRowsOnly ? 0 : rowIndices.rowIndexStart + numFrozenRows;
            // if rendering frozen rows/columns, subtract one to convert to
            // 0-indexing. if the 1-indexed value is 0, this sets the end index
            // to -1, which avoids rendering absent frozen rows/columns at all.
            const columnIndexEnd = showFrozenColumnsOnly ? numFrozenColumns - 1 : columnIndices.columnIndexEnd;
            const rowIndexEnd = showFrozenRowsOnly ? numFrozenRows - 1 : rowIndices.rowIndexEnd;
            // the main quadrant contains all cells in the table, so listen only to that quadrant
            const onCompleteRender = quadrantType === QuadrantType.MAIN ? this.handleCompleteRender : undefined;
            return (React.createElement("div", null,
                React.createElement(TableBody, { enableMultipleSelection: enableMultipleSelection, cellRenderer: this.bodyCellRenderer, focusedCell: focusedCell, grid: this.grid, loading: this.hasLoadingOption(loadingOptions, TableLoadingOption.CELLS), locator: this.locator, onCompleteRender: onCompleteRender, onFocusedCell: this.handleFocus, onSelection: this.getEnabledSelectionHandler(RegionCardinality.CELLS), bodyContextMenuRenderer: bodyContextMenuRenderer, renderMode: this.getNormalizedRenderMode(), selectedRegions: selectedRegions, selectedRegionTransform: selectedRegionTransform, viewportRect: viewportRect, columnIndexStart: columnIndexStart, columnIndexEnd: columnIndexEnd, rowIndexStart: rowIndexStart, rowIndexEnd: rowIndexEnd, numFrozenColumns: showFrozenColumnsOnly ? numFrozenColumns : undefined, numFrozenRows: showFrozenRowsOnly ? numFrozenRows : undefined }),
                this.maybeRenderRegions(this.styleBodyRegion, quadrantType)));
        };
        this.handleCompleteRender = () => {
            // the first onCompleteRender is triggered before the viewportRect is
            // defined and the second after the viewportRect has been set. the cells
            // will only actually render once the viewportRect is defined though, so
            // we defer invoking onCompleteRender until that check passes.
            if (this.state.viewportRect != null) {
                CoreUtils.safeInvoke(this.props.onCompleteRender);
                this.didCompletelyMount = true;
            }
        };
        this.handleFocusMoveLeft = (e) => this.handleFocusMove(e, "left");
        this.handleFocusMoveLeftInternal = (e) => this.handleFocusMoveInternal(e, "left");
        this.handleFocusMoveRight = (e) => this.handleFocusMove(e, "right");
        this.handleFocusMoveRightInternal = (e) => this.handleFocusMoveInternal(e, "right");
        this.handleFocusMoveUp = (e) => this.handleFocusMove(e, "up");
        this.handleFocusMoveUpInternal = (e) => this.handleFocusMoveInternal(e, "up");
        this.handleFocusMoveDown = (e) => this.handleFocusMove(e, "down");
        this.handleFocusMoveDownInternal = (e) => this.handleFocusMoveInternal(e, "down");
        this.styleBodyRegion = (region, quadrantType) => {
            const { numFrozenColumns } = this.props;
            const cardinality = Regions.getRegionCardinality(region);
            const style = this.grid.getRegionStyle(region);
            // ensure we're not showing borders at the boundary of the frozen-columns area
            const canHideRightBorder = (quadrantType === QuadrantType.TOP_LEFT || quadrantType === QuadrantType.LEFT) &&
                numFrozenColumns != null &&
                numFrozenColumns > 0;
            const fixedHeight = this.grid.getHeight();
            const fixedWidth = this.grid.getWidth();
            // include a correction in some cases to hide borders along quadrant boundaries
            const alignmentCorrection = 1;
            const alignmentCorrectionString = `-${alignmentCorrection}px`;
            switch (cardinality) {
                case RegionCardinality.CELLS:
                    return style;
                case RegionCardinality.FULL_COLUMNS:
                    style.top = alignmentCorrectionString;
                    style.height = fixedHeight + alignmentCorrection;
                    return style;
                case RegionCardinality.FULL_ROWS:
                    style.left = alignmentCorrectionString;
                    style.width = fixedWidth + alignmentCorrection;
                    if (canHideRightBorder) {
                        style.right = alignmentCorrectionString;
                    }
                    return style;
                case RegionCardinality.FULL_TABLE:
                    style.left = alignmentCorrectionString;
                    style.top = alignmentCorrectionString;
                    style.width = fixedWidth + alignmentCorrection;
                    style.height = fixedHeight + alignmentCorrection;
                    if (canHideRightBorder) {
                        style.right = alignmentCorrectionString;
                    }
                    return style;
                default:
                    return { display: "none" };
            }
        };
        this.styleMenuRegion = (region) => {
            const { viewportRect } = this.state;
            if (viewportRect == null) {
                return {};
            }
            const cardinality = Regions.getRegionCardinality(region);
            const style = this.grid.getRegionStyle(region);
            switch (cardinality) {
                case RegionCardinality.FULL_TABLE:
                    style.right = "0px";
                    style.bottom = "0px";
                    style.top = "0px";
                    style.left = "0px";
                    style.borderBottom = "none";
                    style.borderRight = "none";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        this.styleColumnHeaderRegion = (region) => {
            const { viewportRect } = this.state;
            if (viewportRect == null) {
                return {};
            }
            const cardinality = Regions.getRegionCardinality(region);
            const style = this.grid.getRegionStyle(region);
            switch (cardinality) {
                case RegionCardinality.FULL_TABLE:
                    style.left = "-1px";
                    style.borderLeft = "none";
                    style.bottom = "-1px";
                    return style;
                case RegionCardinality.FULL_COLUMNS:
                    style.bottom = "-1px";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        this.styleRowHeaderRegion = (region) => {
            const { viewportRect } = this.state;
            if (viewportRect == null) {
                return {};
            }
            const cardinality = Regions.getRegionCardinality(region);
            const style = this.grid.getRegionStyle(region);
            switch (cardinality) {
                case RegionCardinality.FULL_TABLE:
                    style.top = "-1px";
                    style.borderTop = "none";
                    style.right = "-1px";
                    return style;
                case RegionCardinality.FULL_ROWS:
                    style.right = "-1px";
                    return style;
                default:
                    return { display: "none" };
            }
        };
        this.handleColumnWidthChanged = (columnIndex, width) => {
            const selectedRegions = this.state.selectedRegions;
            const columnWidths = this.state.columnWidths.slice();
            if (Regions.hasFullTable(selectedRegions)) {
                for (let col = 0; col < columnWidths.length; col++) {
                    columnWidths[col] = width;
                }
            }
            if (Regions.hasFullColumn(selectedRegions, columnIndex)) {
                Regions.eachUniqueFullColumn(selectedRegions, (col) => {
                    columnWidths[col] = width;
                });
            }
            else {
                columnWidths[columnIndex] = width;
            }
            this.invalidateGrid();
            this.setState({ columnWidths });
            const { onColumnWidthChanged } = this.props;
            if (onColumnWidthChanged != null) {
                onColumnWidthChanged(columnIndex, width);
            }
        };
        this.handleRowHeightChanged = (rowIndex, height) => {
            const selectedRegions = this.state.selectedRegions;
            const rowHeights = this.state.rowHeights.slice();
            if (Regions.hasFullTable(selectedRegions)) {
                for (let row = 0; row < rowHeights.length; row++) {
                    rowHeights[row] = height;
                }
            }
            if (Regions.hasFullRow(selectedRegions, rowIndex)) {
                Regions.eachUniqueFullRow(selectedRegions, (row) => {
                    rowHeights[row] = height;
                });
            }
            else {
                rowHeights[rowIndex] = height;
            }
            this.invalidateGrid();
            this.setState({ rowHeights });
            const { onRowHeightChanged } = this.props;
            if (onRowHeightChanged != null) {
                onRowHeightChanged(rowIndex, height);
            }
        };
        this.handleRootScroll = (_event) => {
            // Bug #211 - Native browser text selection events can cause the root
            // element to scroll even though it has a overflow:hidden style. The
            // only viable solution to this is to unscroll the element after the
            // browser scrolls it.
            if (this.rootTableElement != null) {
                this.rootTableElement.scrollLeft = 0;
                this.rootTableElement.scrollTop = 0;
            }
        };
        this.handleBodyScroll = (event) => {
            // Prevent the event from propagating to avoid a resize event on the
            // resize sensor.
            event.stopPropagation();
            if (this.locator != null && !this.state.isLayoutLocked) {
                const viewportRect = this.locator.getViewportRect();
                this.updateViewportRect(viewportRect);
            }
        };
        this.clearSelection = (_selectedRegions) => {
            this.handleSelection([]);
        };
        // no good way to call arrow-key keyboard events from tests
        /* istanbul ignore next */
        this.handleFocusMove = (e, direction) => {
            e.preventDefault();
            e.stopPropagation();
            const { focusedCell } = this.state;
            if (focusedCell == null) {
                // halt early if we have a selectedRegionTransform or something else in play that nixes
                // the focused cell.
                return;
            }
            const newFocusedCell = { col: focusedCell.col, row: focusedCell.row, focusSelectionIndex: 0 };
            switch (direction) {
                case "up":
                    newFocusedCell.row -= 1;
                    break;
                case "down":
                    newFocusedCell.row += 1;
                    break;
                case "left":
                    newFocusedCell.col -= 1;
                    break;
                case "right":
                    newFocusedCell.col += 1;
                    break;
                default:
                    break;
            }
            if (newFocusedCell.row < 0 ||
                newFocusedCell.row >= this.grid.numRows ||
                newFocusedCell.col < 0 ||
                newFocusedCell.col >= this.grid.numCols) {
                return;
            }
            // change selection to match new focus cell location
            const newSelectionRegions = [Regions.cell(newFocusedCell.row, newFocusedCell.col)];
            const { selectedRegionTransform } = this.props;
            const transformedSelectionRegions = selectedRegionTransform != null
                ? newSelectionRegions.map(region => selectedRegionTransform(region, e))
                : newSelectionRegions;
            this.handleSelection(transformedSelectionRegions);
            this.handleFocus(newFocusedCell);
            // keep the focused cell in view
            this.scrollBodyToFocusedCell(newFocusedCell);
        };
        // no good way to call arrow-key keyboard events from tests
        /* istanbul ignore next */
        this.handleFocusMoveInternal = (e, direction) => {
            e.preventDefault();
            e.stopPropagation();
            const { focusedCell, selectedRegions } = this.state;
            if (focusedCell == null) {
                // halt early if we have a selectedRegionTransform or something else in play that nixes
                // the focused cell.
                return;
            }
            let newFocusedCell = {
                col: focusedCell.col,
                focusSelectionIndex: focusedCell.focusSelectionIndex,
                row: focusedCell.row,
            };
            // if we're not in any particular focus cell region, and one exists, go to the first cell of the first one
            if (focusedCell.focusSelectionIndex == null && selectedRegions.length > 0) {
                const focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[0], this.grid.numRows, this.grid.numCols);
                newFocusedCell = {
                    col: focusCellRegion.cols[0],
                    focusSelectionIndex: 0,
                    row: focusCellRegion.rows[0],
                };
            }
            else {
                if (selectedRegions.length === 0) {
                    this.handleFocusMove(e, direction);
                    return;
                }
                const focusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[focusedCell.focusSelectionIndex], this.grid.numRows, this.grid.numCols);
                if (focusCellRegion.cols[0] === focusCellRegion.cols[1] &&
                    focusCellRegion.rows[0] === focusCellRegion.rows[1] &&
                    selectedRegions.length === 1) {
                    this.handleFocusMove(e, direction);
                    return;
                }
                switch (direction) {
                    case "up":
                        newFocusedCell = this.moveFocusCell("row", "col", true, newFocusedCell, focusCellRegion);
                        break;
                    case "left":
                        newFocusedCell = this.moveFocusCell("col", "row", true, newFocusedCell, focusCellRegion);
                        break;
                    case "down":
                        newFocusedCell = this.moveFocusCell("row", "col", false, newFocusedCell, focusCellRegion);
                        break;
                    case "right":
                        newFocusedCell = this.moveFocusCell("col", "row", false, newFocusedCell, focusCellRegion);
                        break;
                    default:
                        break;
                }
            }
            if (newFocusedCell.row < 0 ||
                newFocusedCell.row >= this.grid.numRows ||
                newFocusedCell.col < 0 ||
                newFocusedCell.col >= this.grid.numCols) {
                return;
            }
            this.handleFocus(newFocusedCell);
            // keep the focused cell in view
            this.scrollBodyToFocusedCell(newFocusedCell);
        };
        this.scrollBodyToFocusedCell = (focusedCell) => {
            const { row, col } = focusedCell;
            const { viewportRect } = this.state;
            // sort keys in normal CSS position order (per the trusty TRBL/"trouble" acronym)
            // tslint:disable:object-literal-sort-keys
            const viewportBounds = {
                top: viewportRect.top,
                right: viewportRect.left + viewportRect.width,
                bottom: viewportRect.top + viewportRect.height,
                left: viewportRect.left,
            };
            const focusedCellBounds = {
                top: this.grid.getCumulativeHeightBefore(row),
                right: this.grid.getCumulativeWidthAt(col),
                bottom: this.grid.getCumulativeHeightAt(row),
                left: this.grid.getCumulativeWidthBefore(col),
            };
            // tslint:enable:object-literal-sort-keys
            const focusedCellWidth = focusedCellBounds.right - focusedCellBounds.left;
            const focusedCellHeight = focusedCellBounds.bottom - focusedCellBounds.top;
            const isFocusedCellWiderThanViewport = focusedCellWidth > viewportRect.width;
            const isFocusedCellTallerThanViewport = focusedCellHeight > viewportRect.height;
            const ss = {};
            // keep the top end of an overly tall focused cell in view when moving left and right
            // (without this OR check, the body seesaws to fit the top end, then the bottom end, etc.)
            if (focusedCellBounds.top < viewportBounds.top || isFocusedCellTallerThanViewport) {
                // scroll up (minus one pixel to avoid clipping the focused-cell border)
                ss.nextScrollTop = Math.max(0, focusedCellBounds.top - 1);
            }
            else if (focusedCellBounds.bottom > viewportBounds.bottom) {
                // scroll down
                const scrollDelta = focusedCellBounds.bottom - viewportBounds.bottom;
                ss.nextScrollTop = viewportBounds.top + scrollDelta;
            }
            // keep the left end of an overly wide focused cell in view when moving up and down
            if (focusedCellBounds.left < viewportBounds.left || isFocusedCellWiderThanViewport) {
                // scroll left (again minus one additional pixel)
                ss.nextScrollLeft = Math.max(0, focusedCellBounds.left - 1);
            }
            else if (focusedCellBounds.right > viewportBounds.right) {
                // scroll right
                const scrollDelta = focusedCellBounds.right - viewportBounds.right;
                ss.nextScrollLeft = viewportBounds.left + scrollDelta;
            }
            this.syncViewportPosition(ss);
        };
        this.handleFocus = (focusedCell) => {
            if (!this.props.enableFocusedCell) {
                // don't set focus state if focus is not allowed
                return;
            }
            // only set focused cell state if not specified in props
            if (this.props.focusedCell == null) {
                this.setState({ focusedCell });
            }
            CoreUtils.safeInvoke(this.props.onFocusedCell, focusedCell);
        };
        this.handleSelection = (selectedRegions) => {
            // only set selectedRegions state if not specified in props
            if (this.props.selectedRegions == null) {
                this.setState({ selectedRegions });
            }
            const { onSelection } = this.props;
            if (onSelection != null) {
                onSelection(selectedRegions);
            }
        };
        this.handleColumnsReordering = (verticalGuides) => {
            this.setState({ isReordering: true, verticalGuides });
        };
        this.handleColumnsReordered = (oldIndex, newIndex, length) => {
            this.setState({ isReordering: false, verticalGuides: undefined });
            CoreUtils.safeInvoke(this.props.onColumnsReordered, oldIndex, newIndex, length);
        };
        this.handleRowsReordering = (horizontalGuides) => {
            this.setState({ isReordering: true, horizontalGuides });
        };
        this.handleRowsReordered = (oldIndex, newIndex, length) => {
            this.setState({ isReordering: false, horizontalGuides: undefined });
            CoreUtils.safeInvoke(this.props.onRowsReordered, oldIndex, newIndex, length);
        };
        this.handleLayoutLock = (isLayoutLocked = false) => {
            this.setState({ isLayoutLocked });
        };
        this.hasLoadingOption = (loadingOptions, loadingOption) => {
            if (loadingOptions == null) {
                return undefined;
            }
            return loadingOptions.indexOf(loadingOption) >= 0;
        };
        this.updateViewportRect = (nextViewportRect) => {
            const { viewportRect } = this.state;
            this.setState({ viewportRect: nextViewportRect });
            const didViewportChange = (viewportRect != null && !viewportRect.equals(nextViewportRect)) ||
                (viewportRect == null && nextViewportRect != null);
            if (didViewportChange) {
                this.invokeOnVisibleCellsChangeCallback(nextViewportRect);
            }
        };
        this.getMaxFrozenColumnIndex = () => {
            const { numFrozenColumnsClamped: numFrozenColumns } = this.state;
            return numFrozenColumns != null ? numFrozenColumns - 1 : undefined;
        };
        this.getMaxFrozenRowIndex = () => {
            const { numFrozenRowsClamped: numFrozenRows } = this.state;
            return numFrozenRows != null ? numFrozenRows - 1 : undefined;
        };
        this.handleColumnResizeGuide = (verticalGuides) => {
            this.setState({ verticalGuides });
        };
        this.handleRowResizeGuide = (horizontalGuides) => {
            this.setState({ horizontalGuides });
        };
        const { children, columnWidths, defaultRowHeight, defaultColumnWidth, numRows, rowHeights } = this.props;
        const childrenArray = React.Children.toArray(children);
        const columnIdToIndex = Table_1.createColumnIdIndex(childrenArray);
        // Create height/width arrays using the lengths from props and
        // children, the default values from props, and finally any sparse
        // arrays passed into props.
        let newColumnWidths = childrenArray.map(() => defaultColumnWidth);
        newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);
        let newRowHeights = Utils.times(numRows, () => defaultRowHeight);
        newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);
        const selectedRegions = props.selectedRegions == null ? [] : props.selectedRegions;
        const focusedCell = FocusedCellUtils.getInitialFocusedCell(props.enableFocusedCell, props.focusedCell, undefined, selectedRegions);
        this.state = {
            childrenArray,
            columnIdToIndex,
            columnWidths: newColumnWidths,
            focusedCell,
            isLayoutLocked: false,
            isReordering: false,
            numFrozenColumnsClamped: clampNumFrozenColumns(props),
            numFrozenRowsClamped: clampNumFrozenRows(props),
            rowHeights: newRowHeights,
            selectedRegions,
        };
    }
    static getDerivedStateFromProps(props, state) {
        const { children, defaultColumnWidth, defaultRowHeight, enableFocusedCell, focusedCell, numRows, selectedRegions, selectionModes, } = props;
        // assign values from state if uncontrolled
        let { columnWidths, rowHeights } = props;
        if (columnWidths == null) {
            columnWidths = state.columnWidths;
        }
        if (rowHeights == null) {
            rowHeights = state.rowHeights;
        }
        const newChildrenArray = React.Children.toArray(children);
        const didChildrenChange = newChildrenArray !== state.childrenArray;
        const numCols = newChildrenArray.length;
        let newColumnWidths = columnWidths;
        if (columnWidths !== state.columnWidths || didChildrenChange) {
            // Try to maintain widths of columns by looking up the width of the
            // column that had the same `ID` prop. If none is found, use the
            // previous width at the same index.
            const previousColumnWidths = newChildrenArray.map((child, index) => {
                const mappedIndex = state.columnIdToIndex[child.props.id];
                return state.columnWidths[mappedIndex != null ? mappedIndex : index];
            });
            // Make sure the width/height arrays have the correct length, but keep
            // as many existing widths/heights as possible. Also, apply the
            // sparse width/heights from props.
            newColumnWidths = Utils.arrayOfLength(newColumnWidths, numCols, defaultColumnWidth);
            newColumnWidths = Utils.assignSparseValues(newColumnWidths, previousColumnWidths);
            newColumnWidths = Utils.assignSparseValues(newColumnWidths, columnWidths);
        }
        let newRowHeights = rowHeights;
        if (rowHeights !== state.rowHeights || numRows !== state.rowHeights.length) {
            newRowHeights = Utils.arrayOfLength(newRowHeights, numRows, defaultRowHeight);
            newRowHeights = Utils.assignSparseValues(newRowHeights, rowHeights);
        }
        let newSelectedRegions = selectedRegions;
        if (selectedRegions == null) {
            // if we're in uncontrolled mode, filter out all selected regions that don't
            // fit in the current new table dimensions
            newSelectedRegions = state.selectedRegions.filter(region => {
                const regionCardinality = Regions.getRegionCardinality(region);
                return (Table_1.isSelectionModeEnabled(props, regionCardinality, selectionModes) &&
                    Regions.isRegionValidForTable(region, numRows, numCols));
            });
        }
        const newFocusedCell = FocusedCellUtils.getInitialFocusedCell(enableFocusedCell, focusedCell, state.focusedCell, newSelectedRegions);
        const nextState = {
            childrenArray: newChildrenArray,
            columnIdToIndex: didChildrenChange ? Table_1.createColumnIdIndex(newChildrenArray) : state.columnIdToIndex,
            columnWidths: newColumnWidths,
            focusedCell: newFocusedCell,
            numFrozenColumnsClamped: clampNumFrozenColumns(props),
            numFrozenRowsClamped: clampNumFrozenRows(props),
            rowHeights: newRowHeights,
            selectedRegions: newSelectedRegions,
        };
        if (!CoreUtils.deepCompareKeys(state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST)) {
            return nextState;
        }
        return null;
    }
    static createColumnIdIndex(children) {
        const columnIdToIndex = {};
        for (let i = 0; i < children.length; i++) {
            const key = children[i].props.id;
            if (key != null) {
                columnIdToIndex[String(key)] = i;
            }
        }
        return columnIdToIndex;
    }
    static isSelectionModeEnabled(props, selectionMode, selectionModes = props.selectionModes) {
        const { children, numRows } = props;
        const numColumns = React.Children.count(children);
        return selectionModes.indexOf(selectionMode) >= 0 && numRows > 0 && numColumns > 0;
    }
    // Instance methods
    // ================
    /**
     * __Experimental!__ Resizes all rows in the table to the approximate
     * maximum height of wrapped cell content in each row. Works best when each
     * cell contains plain text of a consistent font style (though font style
     * may vary between cells). Since this function uses approximate
     * measurements, results may not be perfect.
     *
     * Approximation parameters can be configured for the entire table or on a
     * per-cell basis. Default values are fine-tuned to work well with default
     * Table font styles.
     */
    resizeRowsByApproximateHeight(getCellText, options) {
        const { numRows } = this.props;
        const { columnWidths } = this.state;
        const numColumns = columnWidths.length;
        const rowHeights = [];
        for (let rowIndex = 0; rowIndex < numRows; rowIndex++) {
            let maxCellHeightInRow = 0;
            // iterate through each cell in the row
            for (let columnIndex = 0; columnIndex < numColumns; columnIndex++) {
                // resolve all parameters to raw values
                const { getApproximateCharWidth: approxCharWidth, getApproximateLineHeight: approxLineHeight, getCellHorizontalPadding: horizontalPadding, getNumBufferLines: numBufferLines, } = this.resolveResizeRowsByApproximateHeightOptions(options, rowIndex, columnIndex);
                const cellText = getCellText(rowIndex, columnIndex);
                const approxCellHeight = Utils.getApproxCellHeight(cellText, columnWidths[columnIndex], approxCharWidth, approxLineHeight, horizontalPadding, numBufferLines);
                if (approxCellHeight > maxCellHeightInRow) {
                    maxCellHeightInRow = approxCellHeight;
                }
            }
            rowHeights.push(maxCellHeightInRow);
        }
        this.invalidateGrid();
        this.setState({ rowHeights });
    }
    /**
     * Resize all rows in the table to the height of the tallest visible cell in the specified columns.
     * If no indices are provided, default to using the tallest visible cell from all columns in view.
     */
    resizeRowsByTallestCell(columnIndices) {
        let tallest = 0;
        if (columnIndices == null) {
            // Consider all columns currently in viewport
            const viewportColumnIndices = this.grid.getColumnIndicesInRect(this.state.viewportRect);
            for (let col = viewportColumnIndices.columnIndexStart; col <= viewportColumnIndices.columnIndexEnd; col++) {
                tallest = Math.max(tallest, this.locator.getTallestVisibleCellInColumn(col));
            }
        }
        else {
            const columnIndicesArray = Array.isArray(columnIndices) ? columnIndices : [columnIndices];
            const tallestByColumns = columnIndicesArray.map(col => this.locator.getTallestVisibleCellInColumn(col));
            tallest = Math.max(...tallestByColumns);
        }
        const rowHeights = Array(this.state.rowHeights.length).fill(tallest);
        this.invalidateGrid();
        this.setState({ rowHeights });
    }
    /**
     * Scrolls the table to the target region in a fashion appropriate to the target region's
     * cardinality:
     *
     * - CELLS: Scroll the top-left cell in the target region to the top-left corner of the viewport.
     * - FULL_ROWS: Scroll the top-most row in the target region to the top of the viewport.
     * - FULL_COLUMNS: Scroll the left-most column in the target region to the left side of the viewport.
     * - FULL_TABLE: Scroll the top-left cell in the table to the top-left corner of the viewport.
     *
     * If there are active frozen rows and/or columns, the target region will be positioned in the
     * top-left corner of the non-frozen area (unless the target region itself is in the frozen
     * area).
     *
     * If the target region is close to the bottom-right corner of the table, this function will
     * simply scroll the target region as close to the top-left as possible until the bottom-right
     * corner is reached.
     */
    scrollToRegion(region) {
        const { numFrozenColumnsClamped: numFrozenColumns, numFrozenRowsClamped: numFrozenRows } = this.state;
        const { left: currScrollLeft, top: currScrollTop } = this.state.viewportRect;
        const { scrollLeft, scrollTop } = ScrollUtils.getScrollPositionForRegion(region, currScrollLeft, currScrollTop, this.grid.getCumulativeWidthBefore, this.grid.getCumulativeHeightBefore, numFrozenRows, numFrozenColumns);
        const correctedScrollLeft = this.shouldDisableHorizontalScroll() ? 0 : scrollLeft;
        const correctedScrollTop = this.shouldDisableVerticalScroll() ? 0 : scrollTop;
        // defer to the quadrant stack to keep all quadrant positions in sync
        this.quadrantStackInstance.scrollToPosition(correctedScrollLeft, correctedScrollTop);
    }
    // React lifecycle
    // ===============
    getChildContext() {
        return {
            enableColumnInteractionBar: this.props.enableColumnInteractionBar,
        };
    }
    shouldComponentUpdate(nextProps, nextState) {
        const propKeysBlacklist = { exclude: Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST };
        const stateKeysBlacklist = { exclude: Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST };
        return (!CoreUtils.shallowCompareKeys(this.props, nextProps, propKeysBlacklist) ||
            !CoreUtils.shallowCompareKeys(this.state, nextState, stateKeysBlacklist) ||
            !CoreUtils.deepCompareKeys(this.props, nextProps, Table_1.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST) ||
            !CoreUtils.deepCompareKeys(this.state, nextState, Table_1.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST));
    }
    render() {
        const { children, className, enableRowHeader, loadingOptions, numRows, enableColumnInteractionBar, } = this.props;
        const { horizontalGuides, numFrozenColumnsClamped, numFrozenRowsClamped, verticalGuides } = this.state;
        this.validateGrid();
        const classes = classNames(Classes.TABLE_CONTAINER, {
            [Classes.TABLE_REORDERING]: this.state.isReordering,
            [Classes.TABLE_NO_VERTICAL_SCROLL]: this.shouldDisableVerticalScroll(),
            [Classes.TABLE_NO_HORIZONTAL_SCROLL]: this.shouldDisableHorizontalScroll(),
            [Classes.TABLE_SELECTION_ENABLED]: Table_1.isSelectionModeEnabled(this.props, RegionCardinality.CELLS),
            [Classes.TABLE_NO_ROWS]: numRows === 0,
        }, className);
        return (React.createElement("div", { className: classes, ref: this.refHandlers.rootTable, onScroll: this.handleRootScroll },
            React.createElement(TableQuadrantStack, { bodyRef: this.refHandlers.cellContainer, bodyRenderer: this.renderBody, columnHeaderCellRenderer: this.renderColumnHeader, columnHeaderRef: this.refHandlers.columnHeader, enableColumnInteractionBar: enableColumnInteractionBar, enableRowHeader: enableRowHeader, grid: this.grid, handleColumnResizeGuide: this.handleColumnResizeGuide, handleColumnsReordering: this.handleColumnsReordering, handleRowResizeGuide: this.handleRowResizeGuide, handleRowsReordering: this.handleRowsReordering, isHorizontalScrollDisabled: this.shouldDisableHorizontalScroll(), isVerticalScrollDisabled: this.shouldDisableVerticalScroll(), loadingOptions: loadingOptions, numColumns: React.Children.count(children), numFrozenColumns: numFrozenColumnsClamped, numFrozenRows: numFrozenRowsClamped, numRows: numRows, onScroll: this.handleBodyScroll, ref: this.refHandlers.quadrantStack, menuRenderer: this.renderMenu, rowHeaderCellRenderer: this.renderRowHeader, rowHeaderRef: this.refHandlers.rowHeader, scrollContainerRef: this.refHandlers.scrollContainer }),
            React.createElement("div", { className: classNames(Classes.TABLE_OVERLAY_LAYER, Classes.TABLE_OVERLAY_REORDERING_CURSOR) }),
            React.createElement(GuideLayer, { className: Classes.TABLE_RESIZE_GUIDES, verticalGuides: verticalGuides, horizontalGuides: horizontalGuides })));
    }
    renderHotkeys() {
        const hotkeys = [
            this.maybeRenderCopyHotkey(),
            this.maybeRenderSelectAllHotkey(),
            this.maybeRenderFocusHotkeys(),
            this.maybeRenderSelectionResizeHotkeys(),
        ];
        return React.createElement(Hotkeys, null, hotkeys.filter(element => element !== undefined));
    }
    /**
     * When the component mounts, the HTML Element refs will be available, so
     * we constructor the Locator, which queries the elements' bounding
     * ClientRects.
     */
    componentDidMount() {
        this.validateGrid();
        this.locator = new Locator(this.rootTableElement, this.scrollContainerElement, this.cellContainerElement);
        this.updateLocator();
        this.updateViewportRect(this.locator.getViewportRect());
        this.resizeSensorDetach = ResizeSensor.attach(this.rootTableElement, () => {
            if (!this.state.isLayoutLocked) {
                this.updateViewportRect(this.locator.getViewportRect());
            }
        });
    }
    componentWillUnmount() {
        if (this.resizeSensorDetach != null) {
            this.resizeSensorDetach();
            delete this.resizeSensorDetach;
        }
        this.didCompletelyMount = false;
    }
    getSnapshotBeforeUpdate() {
        const { viewportRect } = this.state;
        this.validateGrid();
        const tableBottom = this.grid.getCumulativeHeightAt(this.grid.numRows - 1);
        const tableRight = this.grid.getCumulativeWidthAt(this.grid.numCols - 1);
        const nextScrollTop = tableBottom < viewportRect.top + viewportRect.height
            ? // scroll the last row into view
                Math.max(0, tableBottom - viewportRect.height)
            : undefined;
        const nextScrollLeft = tableRight < viewportRect.left + viewportRect.width
            ? // scroll the last column into view
                Math.max(0, tableRight - viewportRect.width)
            : undefined;
        // these will only be defined if they differ from viewportRect
        return { nextScrollLeft, nextScrollTop };
    }
    componentDidUpdate(prevProps, prevState, snapshot) {
        super.componentDidUpdate(prevProps, prevState, snapshot);
        const didChildrenChange = React.Children.toArray(this.props.children) !==
            this.state.childrenArray;
        const shouldInvalidateGrid = didChildrenChange ||
            this.props.columnWidths !== prevState.columnWidths ||
            (this.props.rowHeights !== prevState.rowHeights || this.props.numRows !== prevProps.numRows) ||
            (this.props.forceRerenderOnSelectionChange && this.props.selectedRegions !== prevProps.selectedRegions);
        if (shouldInvalidateGrid) {
            this.invalidateGrid();
        }
        if (this.locator != null) {
            this.validateGrid();
            this.updateLocator();
        }
        // When true, we'll need to imperatively synchronize quadrant views after
        // the update. This check lets us avoid expensively diff'ing columnWidths
        // and rowHeights in <TableQuadrantStack> on each update.
        const didUpdateColumnOrRowSizes = !CoreUtils.arraysEqual(this.state.columnWidths, prevState.columnWidths) ||
            !CoreUtils.arraysEqual(this.state.rowHeights, prevState.rowHeights);
        if (didUpdateColumnOrRowSizes) {
            this.quadrantStackInstance.synchronizeQuadrantViews();
            this.syncViewportPosition(snapshot);
        }
    }
    validateProps(props) {
        const { children, columnWidths, numFrozenColumns, numFrozenRows, numRows, rowHeights } = props;
        const numColumns = React.Children.count(children);
        // do cheap error-checking first.
        if (numRows != null && numRows < 0) {
            throw new Error(Errors.TABLE_NUM_ROWS_NEGATIVE);
        }
        if (numFrozenRows != null && numFrozenRows < 0) {
            throw new Error(Errors.TABLE_NUM_FROZEN_ROWS_NEGATIVE);
        }
        if (numFrozenColumns != null && numFrozenColumns < 0) {
            throw new Error(Errors.TABLE_NUM_FROZEN_COLUMNS_NEGATIVE);
        }
        if (numRows != null && rowHeights != null && rowHeights.length !== numRows) {
            throw new Error(Errors.TABLE_NUM_ROWS_ROW_HEIGHTS_MISMATCH);
        }
        if (numColumns != null && columnWidths != null && columnWidths.length !== numColumns) {
            throw new Error(Errors.TABLE_NUM_COLUMNS_COLUMN_WIDTHS_MISMATCH);
        }
        React.Children.forEach(children, child => {
            if (!CoreUtils.isElementOfType(child, Column)) {
                throw new Error(Errors.TABLE_NON_COLUMN_CHILDREN_WARNING);
            }
        });
        // these are recoverable scenarios, so just print a warning.
        if (numFrozenRows != null && numRows != null && numFrozenRows > numRows) {
            console.warn(Errors.TABLE_NUM_FROZEN_ROWS_BOUND_WARNING);
        }
        if (numFrozenColumns != null && numFrozenColumns > numColumns) {
            console.warn(Errors.TABLE_NUM_FROZEN_COLUMNS_BOUND_WARNING);
        }
    }
    // Hotkeys
    // =======
    maybeRenderCopyHotkey() {
        const { getCellClipboardData } = this.props;
        if (getCellClipboardData != null) {
            return (React.createElement(Hotkey, { key: "copy-hotkey", label: "Copy selected table cells", group: "Table", combo: "mod+c", onKeyDown: this.handleCopy }));
        }
        else {
            return undefined;
        }
    }
    maybeRenderSelectionResizeHotkeys() {
        const { enableMultipleSelection, selectionModes } = this.props;
        const isSomeSelectionModeEnabled = selectionModes.length > 0;
        if (enableMultipleSelection && isSomeSelectionModeEnabled) {
            return [
                React.createElement(Hotkey, { key: "resize-selection-up", label: "Resize selection upward", group: "Table", combo: "shift+up", onKeyDown: this.handleSelectionResizeUp }),
                React.createElement(Hotkey, { key: "resize-selection-down", label: "Resize selection downward", group: "Table", combo: "shift+down", onKeyDown: this.handleSelectionResizeDown }),
                React.createElement(Hotkey, { key: "resize-selection-left", label: "Resize selection leftward", group: "Table", combo: "shift+left", onKeyDown: this.handleSelectionResizeLeft }),
                React.createElement(Hotkey, { key: "resize-selection-right", label: "Resize selection rightward", group: "Table", combo: "shift+right", onKeyDown: this.handleSelectionResizeRight }),
            ];
        }
        else {
            return undefined;
        }
    }
    maybeRenderFocusHotkeys() {
        const { enableFocusedCell } = this.props;
        if (enableFocusedCell != null) {
            return [
                React.createElement(Hotkey, { key: "move left", label: "Move focus cell left", group: "Table", combo: "left", onKeyDown: this.handleFocusMoveLeft }),
                React.createElement(Hotkey, { key: "move right", label: "Move focus cell right", group: "Table", combo: "right", onKeyDown: this.handleFocusMoveRight }),
                React.createElement(Hotkey, { key: "move up", label: "Move focus cell up", group: "Table", combo: "up", onKeyDown: this.handleFocusMoveUp }),
                React.createElement(Hotkey, { key: "move down", label: "Move focus cell down", group: "Table", combo: "down", onKeyDown: this.handleFocusMoveDown }),
                React.createElement(Hotkey, { key: "move tab", label: "Move focus cell tab", group: "Table", combo: "tab", onKeyDown: this.handleFocusMoveRightInternal, allowInInput: true }),
                React.createElement(Hotkey, { key: "move shift-tab", label: "Move focus cell shift tab", group: "Table", combo: "shift+tab", onKeyDown: this.handleFocusMoveLeftInternal, allowInInput: true }),
                React.createElement(Hotkey, { key: "move enter", label: "Move focus cell enter", group: "Table", combo: "enter", onKeyDown: this.handleFocusMoveDownInternal, allowInInput: true }),
                React.createElement(Hotkey, { key: "move shift-enter", label: "Move focus cell shift enter", group: "Table", combo: "shift+enter", onKeyDown: this.handleFocusMoveUpInternal, allowInInput: true }),
            ];
        }
        else {
            return [];
        }
    }
    maybeRenderSelectAllHotkey() {
        if (Table_1.isSelectionModeEnabled(this.props, RegionCardinality.FULL_TABLE)) {
            return (React.createElement(Hotkey, { key: "select-all-hotkey", label: "Select all", group: "Table", combo: "mod+a", onKeyDown: this.handleSelectAllHotkey }));
        }
        else {
            return undefined;
        }
    }
    /**
     * Replaces the selected region at the specified array index, with the
     * region provided.
     */
    updateSelectedRegionAtIndex(region, index) {
        const { children, numRows } = this.props;
        const { selectedRegions } = this.state;
        const numColumns = React.Children.count(children);
        const maxRowIndex = Math.max(0, numRows - 1);
        const maxColumnIndex = Math.max(0, numColumns - 1);
        const clampedNextRegion = Regions.clampRegion(region, maxRowIndex, maxColumnIndex);
        const nextSelectedRegions = Regions.update(selectedRegions, clampedNextRegion, index);
        this.handleSelection(nextSelectedRegions);
    }
    // Quadrant refs
    // =============
    moveFocusCell(primaryAxis, secondaryAxis, isUpOrLeft, newFocusedCell, focusCellRegion) {
        const { selectedRegions } = this.state;
        const primaryAxisPlural = primaryAxis === "row" ? "rows" : "cols";
        const secondaryAxisPlural = secondaryAxis === "row" ? "rows" : "cols";
        const movementDirection = isUpOrLeft ? -1 : +1;
        const regionIntervalIndex = isUpOrLeft ? 1 : 0;
        // try moving the cell in the direction along the primary axis
        newFocusedCell[primaryAxis] += movementDirection;
        const isPrimaryIndexOutOfBounds = isUpOrLeft
            ? newFocusedCell[primaryAxis] < focusCellRegion[primaryAxisPlural][0]
            : newFocusedCell[primaryAxis] > focusCellRegion[primaryAxisPlural][1];
        if (isPrimaryIndexOutOfBounds) {
            // if we moved outside the bounds of selection region,
            // move to the start (or end) of the primary axis, and move one along the secondary
            newFocusedCell[primaryAxis] = focusCellRegion[primaryAxisPlural][regionIntervalIndex];
            newFocusedCell[secondaryAxis] += movementDirection;
            const isSecondaryIndexOutOfBounds = isUpOrLeft
                ? newFocusedCell[secondaryAxis] < focusCellRegion[secondaryAxisPlural][0]
                : newFocusedCell[secondaryAxis] > focusCellRegion[secondaryAxisPlural][1];
            if (isSecondaryIndexOutOfBounds) {
                // if moving along the secondary also moves us outside
                // go to the start (or end) of the next (or previous region)
                // (note that if there's only one region you'll be moving to the opposite corner, which is fine)
                let newFocusCellSelectionIndex = newFocusedCell.focusSelectionIndex + movementDirection;
                // newFocusCellSelectionIndex should be one more (or less), unless we need to wrap around
                if (isUpOrLeft ? newFocusCellSelectionIndex < 0 : newFocusCellSelectionIndex >= selectedRegions.length) {
                    newFocusCellSelectionIndex = isUpOrLeft ? selectedRegions.length - 1 : 0;
                }
                const newFocusCellRegion = Regions.getCellRegionFromRegion(selectedRegions[newFocusCellSelectionIndex], this.grid.numRows, this.grid.numCols);
                newFocusedCell = {
                    col: newFocusCellRegion.cols[regionIntervalIndex],
                    focusSelectionIndex: newFocusCellSelectionIndex,
                    row: newFocusCellRegion.rows[regionIntervalIndex],
                };
            }
        }
        return newFocusedCell;
    }
    shouldDisableVerticalScroll() {
        const { enableGhostCells } = this.props;
        const { viewportRect } = this.state;
        const rowIndices = this.grid.getRowIndicesInRect(viewportRect, enableGhostCells);
        const isViewportUnscrolledVertically = viewportRect != null && viewportRect.top === 0;
        const areRowHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.ROW_HEADERS);
        const areGhostRowsVisible = enableGhostCells && this.grid.isGhostIndex(rowIndices.rowIndexEnd, 0);
        return areGhostRowsVisible && (isViewportUnscrolledVertically || areRowHeadersLoading);
    }
    shouldDisableHorizontalScroll() {
        const { enableGhostCells } = this.props;
        const { viewportRect } = this.state;
        const columnIndices = this.grid.getColumnIndicesInRect(viewportRect, enableGhostCells);
        const isViewportUnscrolledHorizontally = viewportRect != null && viewportRect.left === 0;
        const areGhostColumnsVisible = enableGhostCells && this.grid.isGhostColumn(columnIndices.columnIndexEnd);
        const areColumnHeadersLoading = this.hasLoadingOption(this.props.loadingOptions, TableLoadingOption.COLUMN_HEADERS);
        return areGhostColumnsVisible && (isViewportUnscrolledHorizontally || areColumnHeadersLoading);
    }
    getColumnProps(columnIndex) {
        const column = this.state.childrenArray[columnIndex];
        return column === undefined ? undefined : column.props;
    }
    isGuidesShowing() {
        return this.state.verticalGuides != null || this.state.horizontalGuides != null;
    }
    getEnabledSelectionHandler(selectionMode) {
        if (!Table_1.isSelectionModeEnabled(this.props, selectionMode)) {
            // If the selection mode isn't enabled, return a callback that
            // will clear the selection. For example, if row selection is
            // disabled, clicking on the row header will clear the table's
            // selection. If all selection modes are enabled, clicking on the
            // same region twice will clear the selection.
            return this.clearSelection;
        }
        else {
            return this.handleSelection;
        }
    }
    invalidateGrid() {
        this.grid = null;
    }
    validateGrid() {
        if (this.grid == null) {
            const { defaultRowHeight, defaultColumnWidth } = this.props;
            const { rowHeights, columnWidths } = this.state;
            this.grid = new Grid(rowHeights, columnWidths, Grid.DEFAULT_BLEED, defaultRowHeight, defaultColumnWidth);
            this.invokeOnVisibleCellsChangeCallback(this.state.viewportRect);
        }
    }
    /**
     * Renders a `RegionLayer`, applying styles to the regions using the
     * supplied `IRegionStyler`. `RegionLayer` is a `PureRender` component, so
     * the `IRegionStyler` should be a new instance on every render if we
     * intend to redraw the region layer.
     */
    maybeRenderRegions(getRegionStyle, quadrantType) {
        if (this.isGuidesShowing() && !this.state.isReordering) {
            // we want to show guides *and* the selection styles when reordering rows or columns
            return undefined;
        }
        const regionGroups = Regions.joinStyledRegionGroups(this.state.selectedRegions, this.props.styledRegionGroups, this.state.focusedCell);
        return regionGroups.map((regionGroup, index) => {
            const regionStyles = regionGroup.regions.map(region => getRegionStyle(region, quadrantType));
            return (React.createElement(RegionLayer, { className: classNames(regionGroup.className), key: index, regions: regionGroup.regions, regionStyles: regionStyles }));
        });
    }
    syncViewportPosition({ nextScrollLeft, nextScrollTop }) {
        const { viewportRect } = this.state;
        if (nextScrollLeft !== undefined || nextScrollTop !== undefined) {
            // we need to modify the scroll container explicitly for the viewport to shift. in so
            // doing, we add the size of the header elements, which are not technically part of the
            // "grid" concept (the grid only consists of body cells at present).
            if (nextScrollTop !== undefined) {
                const topCorrection = this.shouldDisableVerticalScroll() ? 0 : this.columnHeaderElement.clientHeight;
                this.scrollContainerElement.scrollTop = nextScrollTop + topCorrection;
            }
            if (nextScrollLeft !== undefined) {
                const leftCorrection = this.shouldDisableHorizontalScroll() || this.rowHeaderElement == null
                    ? 0
                    : this.rowHeaderElement.clientWidth;
                this.scrollContainerElement.scrollLeft = nextScrollLeft + leftCorrection;
            }
            const nextViewportRect = new Rect(nextScrollLeft, nextScrollTop, viewportRect.width, viewportRect.height);
            this.updateViewportRect(nextViewportRect);
        }
    }
    updateLocator() {
        this.locator
            .setGrid(this.grid)
            .setNumFrozenRows(this.state.numFrozenRowsClamped)
            .setNumFrozenColumns(this.state.numFrozenColumnsClamped);
    }
    invokeOnVisibleCellsChangeCallback(viewportRect) {
        const columnIndices = this.grid.getColumnIndicesInRect(viewportRect);
        const rowIndices = this.grid.getRowIndicesInRect(viewportRect);
        CoreUtils.safeInvoke(this.props.onVisibleCellsChange, rowIndices, columnIndices);
    }
    /**
     * Normalizes RenderMode.BATCH_ON_UPDATE into RenderMode.{BATCH,NONE}. We do
     * this because there are actually multiple updates required before the
     * <Table> is considered fully "mounted," and adding that knowledge to child
     * components would lead to tight coupling. Thus, keep it simple for them.
     */
    getNormalizedRenderMode() {
        const { renderMode } = this.props;
        const shouldBatchRender = renderMode === RenderMode.BATCH || (renderMode === RenderMode.BATCH_ON_UPDATE && this.didCompletelyMount);
        return shouldBatchRender ? RenderMode.BATCH : RenderMode.NONE;
    }
    /**
     * Returns an object with option keys mapped to their resolved values
     * (falling back to default values as necessary).
     */
    resolveResizeRowsByApproximateHeightOptions(options, rowIndex, columnIndex) {
        const optionKeys = Object.keys(Table_1.resizeRowsByApproximateHeightDefaults);
        const optionReducer = (agg, key) => {
            agg[key] =
                options != null && options[key] != null
                    ? CoreUtils.safeInvokeOrValue(options[key], rowIndex, columnIndex)
                    : Table_1.resizeRowsByApproximateHeightDefaults[key];
            return agg;
        };
        const resolvedOptions = optionKeys.reduce(optionReducer, {});
        return resolvedOptions;
    }
};
Table.displayName = `${DISPLAYNAME_PREFIX}.Table`;
Table.defaultProps = {
    defaultColumnWidth: 150,
    defaultRowHeight: 20,
    enableFocusedCell: false,
    enableGhostCells: false,
    enableMultipleSelection: true,
    enableRowHeader: true,
    forceRerenderOnSelectionChange: false,
    loadingOptions: [],
    minColumnWidth: 50,
    minRowHeight: 20,
    numFrozenColumns: 0,
    numFrozenRows: 0,
    numRows: 0,
    renderMode: RenderMode.BATCH_ON_UPDATE,
    rowHeaderCellRenderer: renderDefaultRowHeader,
    selectionModes: SelectionModes.ALL,
};
Table.childContextTypes = columnInteractionBarContextTypes;
// these default values for `resizeRowsByApproximateHeight` have been
// fine-tuned to work well with default Table font styles.
Table.resizeRowsByApproximateHeightDefaults = {
    getApproximateCharWidth: 8,
    getApproximateLineHeight: 18,
    getCellHorizontalPadding: 2 * Locator.CELL_HORIZONTAL_PADDING,
    getNumBufferLines: 1,
};
Table.SHALLOW_COMPARE_PROP_KEYS_BLACKLIST = [
    "selectedRegions",
];
Table.SHALLOW_COMPARE_STATE_KEYS_BLACKLIST = [
    "selectedRegions",
    "viewportRect",
];
Table = Table_1 = tslib_1.__decorate([
    HotkeysTarget,
    polyfill
], Table);
export { Table };
function clampNumFrozenColumns(props) {
    const { numFrozenColumns } = props;
    const numColumns = React.Children.count(props.children);
    return clampPotentiallyNullValue(numFrozenColumns, numColumns);
}
function clampNumFrozenRows(props) {
    const { numFrozenRows, numRows } = props;
    return clampPotentiallyNullValue(numFrozenRows, numRows);
}
// add explicit `| null | undefined`, because the params make more sense in this
// order, and you can't have an optional param precede a required param.
function clampPotentiallyNullValue(value, max) {
    return value == null ? 0 : Utils.clamp(value, 0, max);
}
//# sourceMappingURL=table.js.map