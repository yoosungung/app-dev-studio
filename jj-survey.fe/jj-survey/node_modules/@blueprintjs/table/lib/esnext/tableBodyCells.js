/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { AbstractComponent2, Utils as CoreUtils } from "@blueprintjs/core";
import classNames from "classnames";
import * as React from "react";
import { emptyCellRenderer } from "./cell/cell";
import { Batcher } from "./common/batcher";
import * as Classes from "./common/classes";
import { Rect } from "./common/rect";
import { RenderMode } from "./common/renderMode";
const SHALLOW_COMPARE_BLACKLIST = ["viewportRect"];
/**
 * We don't want to reset the batcher when this set of keys changes. Any other
 * changes should reset the batcher's internal cache.
 */
const BATCHER_RESET_PROP_KEYS_BLACKLIST = [
    "columnIndexEnd",
    "columnIndexStart",
    "rowIndexEnd",
    "rowIndexStart",
];
export class TableBodyCells extends AbstractComponent2 {
    constructor() {
        super(...arguments);
        this.batcher = new Batcher();
        // Cell renderers
        // ==============
        this.renderNewCell = (rowIndex, columnIndex) => {
            const { columnIndexEnd, grid, rowIndexEnd } = this.props;
            const extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);
            const isGhost = grid.isGhostIndex(rowIndex, columnIndex);
            return this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost);
        };
        this.renderCell = (rowIndex, columnIndex, extremaClasses, isGhost) => {
            const { cellRenderer, focusedCell, loading, grid } = this.props;
            let baseCell = isGhost ? emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);
            // cellRenderer still may return null
            baseCell = baseCell == null ? emptyCellRenderer() : baseCell;
            const className = classNames(cellClassNames(rowIndex, columnIndex), extremaClasses, {
                [Classes.TABLE_CELL_GHOST]: isGhost,
                [Classes.TABLE_CELL_LEDGER_ODD]: rowIndex % 2 === 1,
                [Classes.TABLE_CELL_LEDGER_EVEN]: rowIndex % 2 === 0,
            }, baseCell.props.className);
            const key = TableBodyCells.cellReactKey(rowIndex, columnIndex);
            const rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);
            const cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;
            const style = { ...baseCell.props.style, ...Rect.style(rect) };
            const isFocused = focusedCell != null && focusedCell.row === rowIndex && focusedCell.col === columnIndex;
            return React.cloneElement(baseCell, { className, key, isFocused, loading: cellLoading, style });
        };
        // Other
        // =====
        this.didViewportRectChange = (nextViewportRect, currViewportRect) => {
            if (nextViewportRect == null && currViewportRect == null) {
                return false;
            }
            else if (nextViewportRect == null || currViewportRect == null) {
                return true;
            }
            else {
                return !nextViewportRect.equals(currViewportRect);
            }
        };
    }
    static cellReactKey(rowIndex, columnIndex) {
        return `cell-${rowIndex}-${columnIndex}`;
    }
    componentDidMount() {
        this.maybeInvokeOnCompleteRender();
    }
    shouldComponentUpdate(nextProps) {
        return (!CoreUtils.shallowCompareKeys(nextProps, this.props, { exclude: SHALLOW_COMPARE_BLACKLIST }) ||
            // "viewportRect" is not a plain object, so we can't just deep
            // compare; we need custom logic.
            this.didViewportRectChange(nextProps.viewportRect, this.props.viewportRect));
    }
    componentDidUpdate(prevProps) {
        const shouldResetBatcher = !CoreUtils.shallowCompareKeys(prevProps, this.props, {
            exclude: BATCHER_RESET_PROP_KEYS_BLACKLIST,
        });
        if (shouldResetBatcher) {
            this.batcher.reset();
        }
        this.maybeInvokeOnCompleteRender();
    }
    componentWillUnmount() {
        this.batcher.cancelOutstandingCallback();
    }
    render() {
        const { renderMode } = this.props;
        const cells = renderMode === RenderMode.BATCH ? this.renderBatchedCells() : this.renderAllCells();
        return React.createElement("div", { className: Classes.TABLE_BODY_CELLS }, cells);
    }
    // Render modes
    // ============
    renderBatchedCells() {
        const { columnIndexEnd, columnIndexStart, rowIndexEnd, rowIndexStart } = this.props;
        // render cells in batches
        this.batcher.startNewBatch();
        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
            for (let columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
                this.batcher.addArgsToBatch(rowIndex, columnIndex);
            }
        }
        this.batcher.removeOldAddNew(this.renderNewCell);
        if (!this.batcher.isDone()) {
            this.batcher.idleCallback(() => this.forceUpdate());
        }
        return this.batcher.getList();
    }
    renderAllCells() {
        const { columnIndexEnd, columnIndexStart, rowIndexEnd, rowIndexStart } = this.props;
        const cells = [];
        const cellsArgs = [];
        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {
            for (let columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {
                cells.push(this.renderNewCell(rowIndex, columnIndex));
                cellsArgs.push([rowIndex, columnIndex]);
            }
        }
        // pretend we did an entire rendering pass using the batcher. that way,
        // if we switch from `RenderMode.NONE` to `RenderMode.BATCH`, we don't
        // have to re-paint every cell still in view.
        this.batcher.setList(cellsArgs, cells);
        return cells;
    }
    // Callbacks
    // =========
    maybeInvokeOnCompleteRender() {
        const { onCompleteRender, renderMode } = this.props;
        if (renderMode === RenderMode.NONE || (renderMode === RenderMode.BATCH && this.batcher.isDone())) {
            CoreUtils.safeInvoke(onCompleteRender);
        }
    }
}
TableBodyCells.defaultProps = {
    renderMode: RenderMode.BATCH,
};
/**
 * Returns the array of class names that must be applied to each table
 * cell so that we can locate any cell based on its coordinate.
 */
export function cellClassNames(rowIndex, columnIndex) {
    return [Classes.rowCellIndexClass(rowIndex), Classes.columnCellIndexClass(columnIndex)];
}
//# sourceMappingURL=tableBodyCells.js.map